# vue面试题整理
## 说说SSR
vue.js 是构建客户端应用程序的框架.默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。
然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序.
服务端渲染的优点:
1. 更好SEO:因为SPA页面的内容是通过Ajax 获取,而搜索引擎爬取工具并不会等待Ajax异步完成后再抓取页面内容,所以在SPA中抓取不到页面通过Ajax获取的内容;
而SSR是服务端返回已经渲染好的页面(数据已经包含在页面中),所以搜索引擎爬取工具可以抓取渲染好的页面
2. 更快的内容到达时间(首屏加载更快);SPA或等待所有vue 编译后的js文件都下载完成后，才开始进行页面渲染,文件下载等需要一定的时间，所以首屏渲染需要一定的时间;
SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间
服务端渲染的缺点:
1. 更多开发条件限制：例如服务端只支持beforeCreate 和 created 两个钩子函数,这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行;
并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境
2. 更多的服务器负载:在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，
请准备相应的服务器负载，并明智地采用缓存策略.
## 为什么组件中data必须是一个函数,然后return 一个对象,而new vue 实例里,data 可以直接是一个对象?
因为组件是用来复用的,并且js里对象是引用关系,如果组件是一个对象,那么这样作用域没有隔离，子组件中的data属性值会相互影响,如果组件中data 选项是一个函数,每个实例可以维护一份被返回对象的独立拷贝,
组件实例之间data 属性值不会相互影响;而new Vue的实例,是不会被复用,因此不存在引用对象问题
## vue中computer和普通属性method的区别是什么?
computed 属性是vue计算属性,是数据层到视图层的数据转化映射;只要他的依赖没有发生变化，那么每次访问的时候计算属性都会立即返回之前的计算结果，不再执行函数
1. computed是响应式的,methods并非响应式.
2. 调用方式不一样，computed的定义成员像属性一样访问，methods定义的成员必须以函数形式调用
3. computed是带缓存的，只有依赖数据发生改变，才会重新进行计算，而methods里的函数在每次调用时都要执行。
4. computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的
5. computed不支持异步，当computed内有异步操作时无效，无法监听数据的变化
## 说下vue-router的原理是什么?
实现原理:vue-router的原理就是更新视图而不重新请求页面.
vue-router 可以通过mode参数设置为三种模式:hash模式、history模式、abstract模式.
1. 默认hash模式,基于浏览器history api,调用window.addEventListener('hashChange',callback,false)对浏览器地址进行监听.当调用push时,把新路由添加到浏览器访问历史栈顶;
使用replace时,把浏览器访问历史的栈顶路由替换成新路由hash的值等于url中#及其以后的内容.浏览器根据hash值变化,将页面加载到相应DOM位置.锚点变化只是浏览器的行为,每次锚点变化后依然会在浏览器中留下
一条历史记录,可以通过浏览器的后腿按钮回到上一个位置
2. history模式,基于浏览器history api,使用window.onpopstate 对浏览器地址进行监听,对浏览器history api 中的pushState()、replaceState()进行封装,当方法调用,会对浏览器历史栈进行修改.
从而实现url的跳转而无需加载页面,但是他的问题在于当刷新页面的时候会走后端路由，所以需要服务端的辅助来兜底，避免URL无法匹配到资源时能返回页面
## vuex 和localStorage的区别是什么?
- 最重要区别
 vuex 存储在内存;localstorage已文件的方式储存在本地
 localstorage 只能存储字符串类型的数据,存储对象需要Json的stringify 和parse方法进行处理,读取内存比读取硬盘速度要快
 刷新页面是vuex储存的值会丢失,localStorage不会丢失
- 应用场景
 1. vuex能做到数据的响应式，localstorage不能做到
 2. localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用的
 3. vuex是一个转为为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用域组件之间的传值
 ## 虚拟Dom
  - 什么是虚拟DOM
 虚拟DOM 是一个js 对象,通过对象的方式来表示DOM结构.将页面的状态抽象为js对象的形式,配合不同的渲染工具，使跨平台渲染成为可能.通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，
 从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能
 - 为什么要用虚拟DOM
 1. 保证性能下限，再不进行手动优化的情况下，提供能过得去的性能
 2. 跨平台
 - Virtual Dom 真的比真实DOM性能好么?
 1. 首次渲染大量DOM 时,由于多了一层虚拟DOM的计算,比innerHtml插入慢
 2. 正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的
 ## vue的keep-alive 是如何实现的,具体缓存的是什么
 主要流程
 1. 判断组件name,不在include或者在exclude,直接返回vnode,说明该组件不被缓存
 2. 获取组件实例key，如果由获取实例的key，否则重新生成
 3. key生成规则，cid+"::"+tag，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件
 4. 如果缓存对象内存在，则直接从缓存对象中获取组件实例给vnode，不存在则添加到缓存对象中
 5. 大缓存数量，当缓存数量超过max值时，清楚keys数组内的第一个组件
 
 
