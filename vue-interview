# vue面试题整理
## 说说SSR
vue.js 是构建客户端应用程序的框架.默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。
然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序.
服务端渲染的优点:
1. 更好SEO:因为SPA页面的内容是通过Ajax 获取,而搜索引擎爬取工具并不会等待Ajax异步完成后再抓取页面内容,所以在SPA中抓取不到页面通过Ajax获取的内容;
而SSR是服务端返回已经渲染好的页面(数据已经包含在页面中),所以搜索引擎爬取工具可以抓取渲染好的页面
2. 更快的内容到达时间(首屏加载更快);SPA或等待所有vue 编译后的js文件都下载完成后，才开始进行页面渲染,文件下载等需要一定的时间，所以首屏渲染需要一定的时间;
SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间
服务端渲染的缺点:
1. 更多开发条件限制：例如服务端只支持beforeCreate 和 created 两个钩子函数,这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行;
并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境
2. 更多的服务器负载:在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，
请准备相应的服务器负载，并明智地采用缓存策略.
## 为什么组件中data必须是一个函数,然后return 一个对象,而new vue 实例里,data 可以直接是一个对象?
因为组件是用来复用的,并且js里对象是引用关系,如果组件是一个对象,那么这样作用域没有隔离，子组件中的data属性值会相互影响,如果组件中data 选项是一个函数,每个实例可以维护一份被返回对象的独立拷贝,
组件实例之间data 属性值不会相互影响;而new Vue的实例,是不会被复用,因此不存在引用对象问题
## vue中computer和普通属性method的区别是什么?
computed 属性是vue计算属性,是数据层到视图层的数据转化映射;只要他的依赖没有发生变化，那么每次访问的时候计算属性都会立即返回之前的计算结果，不再执行函数
1. computed是响应式的,methods并非响应式.
2. 调用方式不一样，computed的定义成员像属性一样访问，methods定义的成员必须以函数形式调用
3. computed是带缓存的，只有依赖数据发生改变，才会重新进行计算，而methods里的函数在每次调用时都要执行。
4. computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的
5. computed不支持异步，当computed内有异步操作时无效，无法监听数据的变化
## 说下vue-router的原理是什么?
实现原理:vue-router的原理就是更新视图而不重新请求页面.
vue-router 可以通过mode参数设置为三种模式:hash模式、history模式、abstract模式.
1. 默认hash模式,基于浏览器history api,调用window.addEventListener('hashChange',callback,false)对浏览器地址进行监听.当调用push时,把新路由添加到浏览器访问历史栈顶;
使用replace时,把浏览器访问历史的栈顶路由替换成新路由hash的值等于url中#及其以后的内容.浏览器根据hash值变化,将页面加载到相应DOM位置.锚点变化只是浏览器的行为,每次锚点变化后依然会在浏览器中留下
一条历史记录,可以通过浏览器的后腿按钮回到上一个位置
2. history模式,基于浏览器history api,使用window.onpopstate 对浏览器地址进行监听,对浏览器history api 中的pushState()、replaceState()进行封装,当方法调用,会对浏览器历史栈进行修改.
从而实现url的跳转而无需加载页面,但是他的问题在于当刷新页面的时候会走后端路由，所以需要服务端的辅助来兜底，避免URL无法匹配到资源时能返回页面
